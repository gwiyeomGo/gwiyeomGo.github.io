"use strict";(self.webpackChunkgwiyeom_blog=self.webpackChunkgwiyeom_blog||[]).push([[120],{3141:function(e,n,t){t.r(n),t.d(n,{Head:function(){return s.p},default:function(){return o}});var a=t(6540),l=t(8453);function r(e){const n=Object.assign({h3:"h3",ul:"ul",li:"li",p:"p",h1:"h1",ol:"ol",blockquote:"blockquote",pre:"pre",code:"code"},(0,l.RP)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h3,null,"async  await"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"es2017 도입"),"\n",a.createElement(n.li,null,"프라미스 기반의 비동기 코드를 동기적 코드처럼 작성 할 수 있게 합니다."),"\n",a.createElement(n.li,null,"await 키워드는 async 키워드로 선언된 함수 안에서만 사용"),"\n"),"\n",a.createElement(n.h3,null,"에러"),"\n",a.createElement(n.p,null,"UnhandledPromiseRejection\n에러 메세지 확인"),"\n",a.createElement(n.h1,null,"찾아보니"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"asnyc/await을 사용한 함수는 promise를 반환한다는 것을 알게되었다."),"\n",a.createElement(n.li,null,"async 키워드를 사용한 함수의 경우\ntry "," catch"," 로 애러 핸들안해줘서 발생"),"\n"),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"then/catch 사용"),"\n"),"\n",a.createElement(n.pre,null,a.createElement(n.code,null,"axios.get('https://api.test.com/data').then((response) => {\n  if (response && response.data){\n   axios.getget('https://api.test2.com/data').then((res) => {\n       setData({\n        classification:res.data,\n        donation:response.data\n        });\n    });\n  }\n})\n")),"\n",a.createElement(n.p,null,"then/catch는 프로미스 체이닝을 사용해서\n순차적으로 비동기 작업을 수정할 수 있습니다\n첫 요청이 성공하면 다음 요청을 수행"),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"async/await 사용"),"\n"),"\n",a.createElement(n.pre,null,a.createElement(n.code,null,"const load =  async () => {\n\n  try {\n    const response = await axios.get('https://api.test.com/data');\n    if (response && response.data) {\n      const res = await axios.get('https://api.test2.com/data');\n      setData({\n        classification: res.data,\n        donation: response.data\n      });\n    }\n  } catch (error) {\n    console.error('Error fetching data:', error);\n  }\n};\n")),"\n",a.createElement(n.p,null,"async/await는 비동기 코드를 동기 코드처럼 작성할 수 있어서 직관적\nawait 을 사용해 프로미스가 해결될 때까지 기다리며\ntry catch 로 블록을 사용해 에러처리\nasync/await 디버깅시 스택 트레이스 제공"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"async/await 와 then/catch 혼합해서 사용 비추"),"\n"),"\n",a.createElement(n.pre,null,a.createElement(n.code,null,"const load = async () => {\n  try {\n    const response = await axios.get('https://api.test.com/data')\n      .then(response => {\n        // .then 블록 안에서 또 다른 비동기 요청을 처리\n        return axios.get('https://api.test2.com/data').then(res => {\n          setData({\n            classification: res.data,\n            donation: response.data\n          });\n          return res;\n        });\n      });\n  } catch (error) {\n    console.error('Error fetching data:', error);\n  }\n};\n")),"\n",a.createElement(n.p,null,"await 사용시\n비동기 작업을 동기적으로 작성할 수 있어서\n마치 동기 코드처럼 보입니다"),"\n",a.createElement(n.p,null,"반면 then 은 비동기 체이닝을 사용한 구문입니다"),"\n",a.createElement(n.p,null,"해당 부분이 코드를 읽는 사람이 혼란스러울 수 있습니다.\n두가지 비동기 처리 방식을 이해하고 신경 써야 하기 때문에 가독성을 떨어뜨립니다\ntry catch 와 then 이후 catch 등 중복 사용된다면 정확히 어디서 에러가 처리되는지 알 수 없습니다"))}var c=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.RP)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)},s=t(7292);function o(e){return a.createElement(s.A,e,a.createElement(c,e))}s.A}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-client-javascript-2022-04-11-javascript-async-await-mdx-010d021a0e5dad222870.js.map