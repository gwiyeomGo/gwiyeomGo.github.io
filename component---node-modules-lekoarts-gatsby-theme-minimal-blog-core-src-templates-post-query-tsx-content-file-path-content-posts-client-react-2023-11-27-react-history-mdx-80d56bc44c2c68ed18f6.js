"use strict";(self.webpackChunkgwiyeom_blog=self.webpackChunkgwiyeom_blog||[]).push([[187],{4243:function(e,n,l){l.r(n),l.d(n,{Head:function(){return m.p},default:function(){return u}});var t=l(6540),r=l(8453);function a(e){const n=Object.assign({h1:"h1",p:"p",ol:"ol",li:"li",blockquote:"blockquote",ul:"ul",a:"a",pre:"pre",code:"code"},(0,r.RP)(),e.components);return t.createElement(t.Fragment,null,t.createElement(n.h1,null,"웹 역사"),"\n",t.createElement(n.p,null,"넷스케이프 회사\n웹 브라우저를 개발한 회사\n자바스크립트 언어 개발 => 웹 브라우저를 동적으로 만듬"),"\n",t.createElement(n.ol,null,"\n",t.createElement(n.li,null,"웹 1.0 - 웹 페이지의 시대"),"\n"),"\n",t.createElement(n.p,null,"팀버너스리 -> html 개발 -> 누구나 사용할 수 있도록 http 개발\n-> 누구나 쉽게 벌 수 있도록 월드와이드웹 브라우저"),"\n",t.createElement(n.p,null,"모자이크 브라우저 개발 => 모질라 등 브라우저 출시"),"\n",t.createElement(n.p,null,"자바스크리트 탄생"),"\n",t.createElement(n.p,null,"자바스크립트를 사용한 브라우저 돔 조작은 너무나 복잡하고 불편"),"\n",t.createElement(n.p,null,"jquery .. bootstrap  .. 등 인기"),"\n",t.createElement(n.ol,{start:"2"},"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"웹 2.0 -웹 애플리케이션 시대"),"\n",t.createElement(n.ol,null,"\n",t.createElement(n.li,null,"xmlhttprequest api 등장 -> 새로운 정보를 표시하기 위해 서버에 웹 페이지를 매번 요청하던 방식에 큰 변화를 가져온다"),"\n",t.createElement(n.li,null,"json 데이터 포멧 등장 널리 사용"),"\n",t.createElement(n.li,null,"2004 구글이 ajax 사용"),"\n",t.createElement(n.li,null,"2007,2008 아이폰,안드로이드 등장 -> 애플리케이션 시대","\n",t.createElement(n.blockquote,null,"\n",t.createElement(n.p,null,"싱글 페이지 어플리케이션 (spa) 시대 등장"),"\n"),"\n"),"\n",t.createElement(n.li,null,"2010 angularjs 웹 애플리케이션 프래임워크"),"\n",t.createElement(n.li,null,"2013 react (ui 에 집중한 라이브러리)\njsx: javascript xml 라는 자바스크립트에 html 을 포함하는 간단한 문법 ,단방향 데이터 바인딩 채택"),"\n"),"\n"),"\n"),"\n",t.createElement(n.p,null,"리액트는 페이지 전환에 관한 기능이 존재하지 않아 react-router 등 과 같은 다른 라이브러리를 사용해야 한다\n이러한 문제를 해결하기 위해 nextjs 와 같은 프레임 워크가 등장한다"),"\n",t.createElement(n.h1,null,"리액트 특징"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"jsx\n자바스크립트아 html 동시 사용하며,템플릿 언어"),"\n"),"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"단반향 데이터 바인딩"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"단 하나의 왓처가 자바스크립트의 데이터 갱신을 감지하여 사용자 ui를 갱신"),"\n"),"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"하나의 왓처로 이벤트를 통해 명시적으로 데이터 갱신"),"\n"),"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"명확하게 데이터 추적을 할 수 있다."),"\n"),"\n"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"양방향 데이터 바인딩","\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"싱글 페이지 어플리케이션의 대표적인 프레임워크 앵귤러,뷰는 양방향 데이터 바인딩"),"\n",t.createElement(n.li,null,"사용자 ui의 데이터 변경을 감시하는 왓처와\n자바스크립트 안에서 데이터 변경을 감시하는 왓처를 통해\nui 와 프로그램 안에 데이터를 자동으로 동기화해 주는 기능"),"\n",t.createElement(n.li,null,"데이터를 동기화 해주는 장점도 있지만 데이터 하나에 동기화를 위한 왓처가 두 개 사용되기 때문에 간단한 기능임에도 불구하고 오버 스펙인 경우가 발생"),"\n",t.createElement(n.li,null,"오버 스펙과 수많은 와처에 의한 성능 저하를 발생시킴,이를 방지하기 위해 단방향 데이터 바인딩도 지원한다"),"\n"),"\n"),"\n"),"\n"),"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"flux 라는 개념을 도입: 데이터의 흐름이 한쪽 방향으로만 진행되는 것을 권장\n",t.createElement(n.a,{href:"https://medium.com/hcleedev/web-react-flux-%ED%8C%A8%ED%84%B4-88d6caa13b5b"},"https://medium.com/hcleedev/web-react-flux-%ED%8C%A8%ED%84%B4-88d6caa13b5b")),"\n"),"\n"),"\n",t.createElement(n.p,null,"action-> dispatcher -> store-> view"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"가상 돔"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"브라우저에서 html,css 렌더링"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"사용자가 브라우저를 통해 웹 페이지 요청-> 페이지 html 전달 받음"),"\n",t.createElement(n.li,null,"브라우저는 렌더 엔진을 통해 html 파싱하여 돔 노드로 이루어진 트리를 만든다."),"\n",t.createElement(n.li,null,"css 파일과 각 엘리먼트의 인라인 스타일을 파싱하여 스타일 정보를 가진 스타일 렌더 트리를 만든다."),"\n",t.createElement(n.li,null,"브라우저는 각 노드들에 paint 메소드를 호출하여 색상을 입히는 페인팅 과정 거쳐 최종적 화면에 표시"),"\n"),"\n"),"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"이렇게 표시된 돔 트리를 =>  자바스크립트로 조작 => 리플로,리페인트 (레이아웃 다시 수행,페인팅 과정 다시 수행 )으로 성능 떨굼"),"\n"),"\n"),"\n",t.createElement(n.p,null,"정적인 웹 사이트나 자바스크립트를 사용하여 돔을 변경하는 동작이 적은 웹 페이지인 경우\n크게 문제가 되지는 않지만,싱글 페이지 애플리케이션처럼 사용자와의 상호작용이 많고 돔 변경이 동시 다발적으로 빈번히 발생하는\n사이트인 경우에는 리플로와 리페인트가 많이 발생하면 애플리케이션의 성능 문제가 발생"),"\n",t.createElement(n.p,null,"리액트에서 가상 돔을 도입해 리플로와 리페인트 연산을 최소화함"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"가상돔 : 화면에 표시되는 돔 트리와 동일한 돔 트리에서 모든 연산을 한 후\n실제 돔 트리를 갱신하는 방식으로 리플로와 리페인트 연산을 최소화함"),"\n"),"\n"),"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"선언형 프로그래밍"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"명령형 프로그래밍은 그 값을 얻기 위해 어떻게 하는지 집중"),"\n",t.createElement(n.li,null,"선언형 프로그래밍은 결과값이 무엇인지에 집중"),"\n"),"\n"),"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"컴포넌트 기반\n레고처럼 조합하여 페이지를 제작하는 컴포넌트 기반 프로그래밍\n컴포넌트 주도 개발 방법(CDD)"),"\n"),"\n"),"\n",t.createElement(n.h1,null,"SPA"),"\n",t.createElement(n.p,null,"각 페이지별로 html 파일이 따로 존재하며,\n페이지를 이동하게 될 경우 브라우저에서는 해당 페이지의 html 파일을 받아와서 화면에 표시"),"\n",t.createElement(n.p,null,"html 파일이 수백 개 된다면.."),"\n",t.createElement(n.p,null,"하나의 페이지만 존재하는 웹사이트"),"\n",t.createElement(n.h1,null,"리엑트?"),"\n",t.createElement(n.p,null,"웹과 네이티브 사용자 인터페이스(user Interface)를 위한 라이브러리"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"라이브러리:자주 사용되는 기능을 정리해서 모아 놓은 것"),"\n"),"\n",t.createElement(n.p,null,"사용자 인터페이스를 만들기 위한 기능 모음집을 ui 라이브러리\n리액트는 대표적인 자바스크립트 ui 라이브러리"),"\n",t.createElement(n.h1,null,"프레임워크 vs 라이브러리"),"\n",t.createElement(n.p,null,"프로그램의 흐름에 대한 제어 권한\n프레임워크는 흐름에 제어 권한을 개발자가 아닌 프레임워크가 갖고 있는 반면에,\n라이브러리는 흐름에 대한 제어를 하지 않고 개발자가 필요한 부분민\n필요할 때 가져다 사용하는 형태\n라이브러리는 제어 권한이 : 개발자\n프레임워크 제어 권한 : 프레임워크"),"\n",t.createElement(n.h1,null,"리엑트 장점"),"\n",t.createElement(n.ol,null,"\n",t.createElement(n.li,null,"빠른 업데이트와 렌더링 속도"),"\n"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"가상의 DOM : virtual dom"),"\n",t.createElement(n.li,null,"dom : document object model 의 약자로 웹 페이지를 정의하는 하나의 객체\n리엑트는 dom 을 직접 수정하지 않고 업데이트해야 할 부분만 찾아서 업데이트\n어떤 상태 변경이 일어나면 가상의 돔에서는 업데이트해야 될 최소한의 부분을 검색\n검색된 부분만을 업데이트하고 다시 렌더링하면서 변경된 내용을 빠르게 사용자에게 보여줄 수 있는 것"),"\n"),"\n",t.createElement(n.ol,{start:"2"},"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"컴포넌트 기반"),"\n"),"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"재사용성\n다시 사용이 가능한 성질"),"\n"),"\n"),"\n",t.createElement(n.p,null,"단점\n높은 상태 관리ㅣ 복잡도\nstate 는 리액트 컴포넌트의 상태\nstate 가 바뀐 컴포넌트 = 매번 바뀐 부분 업데이트"),"\n",t.createElement(n.p,null,"웹사이트의 규모가 커져 컴포넌트의 개수가 많아지면 상태 관리의 복잡도도 증가"),"\n",t.createElement(n.p,null,"redux mobx recoil 등의 외부 상태 관리 라이브러리를 사용"),"\n",t.createElement(n.h1,null,"JSX"),"\n",t.createElement(n.p,null,"자바스크립트 확장 문법\njavascript xml/html"),"\n",t.createElement(n.p,null,"리액트는 jsx 코드를 모두 createElement 함수를 사용하는 코드로 변환\njsx 를 사용하는 것은 필수는 아니다.\ncreateElement 를 사용해 개발가능\n하기때문\njsx 를 사용했을 때 코드가 더욱 간결 생산성과 가독성 올라감\n또한 injection Attack (문자,숫자 가아닌 코드 입력해 실행되도록 하는 기법)이라고 불리는 해킹 방법을 방어함으로\n보안성이 올라갑니다.\n-> xss 방어함"),"\n",t.createElement(n.p,null,"jsx 에서 "," 중괄호 사용하면 javascript 코드 들어감"),"\n",t.createElement(n.h1,null,"엘리먼트(어떤 물체를 구성하는 성분)"),"\n",t.createElement(n.p,null,"리액트 앱을 구성하는 요소\n엘리먼트는 리액트 앱의 가장 작은 빌딩 블록"),"\n",t.createElement(n.p,null,"엘리먼트는 원래 웹사이트에 대한 모든 정보를 담고 있는 객체 DOM\n에서 사용하는 용어\n엘리먼트는 dom 엘리먼트로 html 요소\n화면을 나타내는 내용을 기술한 자바스크립트 객체"),"\n",t.createElement(n.p,null,"실제 브라우저의 dom 에 존재하는 엘리먼트는 dom 엘리먼트\n리엑트 virtual dom 에 존재하는 엘리먼트가 바로 리엑트 엘리먼트"),"\n",t.createElement(n.p,null,"리엑트 엘리먼트는 dom 엘리먼트의 가상 표현"),"\n",t.createElement(n.p,null,"dom 엘리먼트"),"\n",t.createElement(n.pre,null,t.createElement(n.code,null,"{\n    type:'button' // html 태그 이름,\n    props: {\n        children :\"\"\n    }\n}\n")),"\n",t.createElement(n.p,null,"리엑트 엘리먼트"),"\n",t.createElement(n.pre,null,t.createElement(n.code,null,"{\n    type:'Button' // 컴포넌트 이름,\n    props: {\n        children :\"\"\n    }\n}\n")),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"컴포넌트 렌터링을 위해서 모든 컴포넌트가 createElement 함수 통해 엘리먼트로 변환"),"\n",t.createElement(n.li,null,"리엑트 엘리먼트 -> 불변성\n한번 생성 후에는 children 이나 속성을 바꿀 수 없다"),"\n",t.createElement(n.li,null,"컴포넌트 = 붕어빵 틀\n새로운 엘리먼트를 만들어서 기존 엘리먼트와 바꿔치기 하는 것\nvirtual dom 이 변경된 부분을 계산하고 해당 부분만 다시 렌더링"),"\n"),"\n",t.createElement(n.p,null,"props 는 같은 리액트 컴포넌트에서 눈에 보이는 글자나 색깔 등의 속성을 바꾸고 싶을 때 사용하는 컴포넌트 속 재료\nprops 는 컴포넌트에 전달할 다양한 정보를 담고 있는 자바스크립트 객체"),"\n",t.createElement(n.p,null,"pure 하다\n입력값을 변경하지 않으며,같은 입력값에 대해서는 항상 같은 출력값을 낸다"),"\n",t.createElement(n.p,null,"inpure 하다\n입력값을 변경"),"\n",t.createElement(n.p,null,"모든 리액트 컴포넌트는 props 를 직접 바꿀 수 없고,props 에 대해서는 항상 같은 결과를 보여줄 것"),"\n",t.createElement(n.p,null,"클래스 컴포넌트 = es6 클레스 사용 컴포넌트"),"\n",t.createElement(n.p,null,"소문자 => dom 이 태그로 인식\n컴포넌트의 이름은 항상 대문자로 시작"),"\n",t.createElement(n.p,null,"컴포넌트는 기능 단위로 구분하는 것이 좋고\n나중에 곧바로 재사용이 가능한 형태로 추출하는 것이 좋다"),"\n",t.createElement(n.h1,null,"state = 리엑트 컴포넌트의 상태"),"\n",t.createElement(n.p,null,"리액트 컴포넌트의 변경 가능한 데이터\n렌더링이나 데이터 흐름에 사용되는 값만 state 에 포함\nstate 가 변경될 경우 컴포넌트가 재랜더링되기 때문에 렌더링과 데이터 흐름에 관련 없는 값을 포함하면 컴포넌트가 다시 렌더링되어 성능을 저하 시킬 수 있다\nstate 는 직접 변경이 불가능 하며 setState()함수를 통해 수정"),"\n",t.createElement(n.h1,null,"분리하기"),"\n",t.createElement(n.p,null,"컴포넌트와 분자, 유기체라는 용어는 프로그래밍에서 특별한 의미를 가지지 않는 일반적인 용어입니다. 하지만 이러한 용어는 소프트웨어 아키텍처나 설계 패턴에 대한 비유적인 용어로 사용될 수 있습니다."),"\n",t.createElement(n.p,null,'"atoms", "molecules", "organisms" 등의 용어는 주로 Brad Frost의 Atomic Design이라는 디자인 시스템 개념에서 나왔습니다. 이 개념에서 "atoms"는 작은 구성 요소, "molecules"는 이러한 구성 요소들이 결합된 것, "organisms"는 더 큰 컴포넌트 또는 모듈을 나타냅니다.'),"\n",t.createElement(n.p,null,'따라서 여러 개의 "atoms"가 결합되어 "molecules"를 형성하고, 그 "molecules"가 더 큰 단위인 "organisms"를 형성하는 식입니다.'),"\n",t.createElement(n.p,null,'여기서 "디바운스 기능을 감싸서 새로운 컴포넌트를 만들었다"는 말은 분자(molecule)를 만들었다고 볼 수 있습니다. 왜냐하면 디바운스 기능이라는 작은 구성 요소(atom)를 사용하여 이를 결합하여 더 큰 기능을 하는 컴포넌트(molecule)를 만들었기 때문입니다.'),"\n",t.createElement(n.p,null,'그러나 정확한 용어나 비유는 프로젝트나 팀의 특정한 문맥이나 규칙에 따라 다를 수 있습니다. 예를 들어, 어떤 팀에서는 "atoms"가 더 작은 단위를 나타내지만 다른 팀에서는 더 큰 단위를 나타내는 경우도 있을 수 있습니다. 따라서 이러한 용어를 사용하는 팀 내에서의 정의나 관행을 확인하는 것이 중요합니다.'),"\n",t.createElement(n.h1,null,"react18"),"\n",t.createElement(n.p,null,"1.자동 배칭\n리액트 컴포넌트는 state 가 업데이트될 때마다 재랜더링 된다.\nstate 와 set 함수를 동시에 호출하면\n호출된 횟수만큼 재랜더링 발생"),"\n",t.createElement(n.p,null,"state 의 업데이트가 동시에 발생할때 여러 작업을 묶어서 한 번에 처리\n이 작업이 배칭"),"\n",t.createElement(n.p,null,"배칭은 컴퓨터 공학에서 여러 작업을 한번에 처리한다는 의미\n여러 state의 업데이트 작업을 한 번에 묶어서 처리하는 것"),"\n",t.createElement(n.p,null,"기존 리액트에서는 이벤트 핸들어 내에서만 배칭이 이뤄짐??"),"\n",t.createElement(n.p,null,"자동 배칭이 추가되면서 state 의 업데이트 작업을 묶어서 한 번에 처리\n추가로 해야하는 작업 없이\n기존과 똑같이 setData,setCount 를 같이 호출해도\n자동으로 묶어서 한번에 처리하여 재랜더링 1번만 발생"),"\n",t.createElement(n.ol,{start:"2"},"\n",t.createElement(n.li,null,"트랜지션\n긴급한 업데이트와 긴급하지 않은 업데이트를 구분해서\n처리하기 위해 등장한 개념"),"\n"),"\n",t.createElement(n.p,null,"긴급한 업데이트와 긴급하지 않은 업데이트 구분?\n긴급: 사용자와 직접적인 인터렉션 (입력,클릭)\n긴급 x :서버에서 결과를 받아와 보여줌"),"\n",t.createElement(n.p,null,"더 나은 사용자 경험을 제공하기 위해"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"입력 간에 키보드로 글자를 넣을 때 몇초가 지나고 나서야\n입력된다.. 이처럼 사용자와 즉각 인터랙션이 발생하는 기능은\n빠르게 처리해야 함으로 긴급한 업데이트로 지정"),"\n"),"\n",t.createElement(n.p,null,"긴급것은 기존과 동일하게 업데이트 (setValue)\n긴급하지 않은 것은 startTransition 함수 사용"),"\n",t.createElement(n.p,null,"? 더 긴급한 업데이트 발생시 startTransition 중단도리 수 있음??"),"\n",t.createElement(n.ol,{start:"3"},"\n",t.createElement(n.li,null,"서스펜스"),"\n"),"\n",t.createElement(n.p,null,"컴포넌트 코드를 여러 조각으로 분리하는 코드 = 스프리팅\n분리된 코드 조각에서 지연 로딩 또는 동작 로딩 기법을 적용해\n반응 속도를 높일 수 있다."),"\n",t.createElement(n.p,null,"suspensed = 유예하다,중단하다 뜻\n16 릴리즈때 등장..."),"\n",t.createElement(n.p,null,"역할?\n하위 컴포넌트 children 준비되기 전까지\n렌더링을 중단한다. 그리고 하위 컴포넌트가 준비된 이후에 렌더링을 진행함으로써\n사용자 경험을 향상 시킨다."),"\n",t.createElement(n.p,null,"기존에는 서스펜스가 코드 스플링과 함께 제한적으로 사용되었지만\n리랙트 18 부터 헨더링과 데이터 페칭(제한적으로) 사용할 수 있게 되었다"),"\n",t.createElement(n.ol,{start:"4"},"\n",t.createElement(n.li,null,"클라이언트와 서버 렌더링 API 업데이트\n(1) 리액트 DOM 클라이언트\n클라이언트 렌더링 방식은\nReactDOM.render 함수를 기존에 렌더링 방식\n18부터 reat-dom/client 추가되면서 createRoot 함수 사용 렌더링 방식 도입"),"\n"),"\n",t.createElement(n.p,null,"새로운 API 를 사용하지 않으면\n리액트 18에서 제공하는 기능을 사용할 수 없기때문에\ncreateRoot 사용해야함\n(2) 리액트 DOM 서버"),"\n",t.createElement(n.p,null,"서버 사이드 렌더링(SSR) 사용을 위해 renderToString()\n사용햇었는데...\nreact-dom/server 의 두 가지 함수 사용해\n서스펜스와 함께 사용할 수 있도록 업데이트"),"\n",t.createElement(n.p,null,"renderToPipealeSteam 노드 환경에서 스티리밍 위한 함수\nrenderToReadableStream 엣지 런타임 환경"),"\n",t.createElement(n.ol,{start:"5"},"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"새로운 Strict 모드 작동 방식\nStrict 모드는 개발 모드에서 잠재적인 버그를 찾을 수 있게\n해주는 모드\nStrict 모드의 동작이 변경되었는데, 개발 모드에서 Strict 모드를 사용하게 되면\n컴포넌트 언마운트한 후에 다시 한번 마운트 하게 된다."),"\n"),"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"새로 추가된  훅"),"\n"),"\n"))}var c=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?t.createElement(n,e,t.createElement(a,e)):a(e)},m=l(7292);function u(e){return t.createElement(m.A,e,t.createElement(c,e))}m.A}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-client-react-2023-11-27-react-history-mdx-80d56bc44c2c68ed18f6.js.map