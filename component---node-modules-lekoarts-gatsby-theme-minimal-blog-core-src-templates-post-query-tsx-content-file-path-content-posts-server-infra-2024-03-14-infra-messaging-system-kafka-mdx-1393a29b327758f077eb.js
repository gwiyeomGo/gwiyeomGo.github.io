"use strict";(self.webpackChunkgwiyeom_blog=self.webpackChunkgwiyeom_blog||[]).push([[1658],{247:function(e,l,n){n.r(l),n.d(l,{Head:function(){return c.p},default:function(){return m}});var t=n(6540),u=n(8453);function r(e){const l=Object.assign({h1:"h1",ul:"ul",li:"li",h2:"h2",p:"p"},(0,u.RP)(),e.components);return t.createElement(t.Fragment,null,t.createElement(l.h1,null,"kafka"),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,"분산 메시지 프레임워크이다."),"\n",t.createElement(l.li,null,"굉장히 안정되어 있고 속도가 빠르다."),"\n",t.createElement(l.li,null,"병령성능과 가용성 기능이 핵심아다."),"\n",t.createElement(l.li,null,"메시지는 여러 파티션에 분산 저장됨"),"\n"),"\n",t.createElement(l.h2,null,"토픽"),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,"메시지를 저장하는 영역이며"),"\n",t.createElement(l.li,null,"토픽은 여러개의 파티션으로 구성된 일련의 로그 파일"),"\n",t.createElement(l.li,null,"키와 값 기반의 메시지 구조이며 다양한 타입의 값 전달 가능"),"\n",t.createElement(l.li,null,"시간의 흐름에 따라 메시지가 순차적으로 물리적인 파일에 write 된다."),"\n"),"\n",t.createElement(l.h2,null,"프로듀셔 :메시지를 보낸다."),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,"성능/로드벨런싱/가용성/업무 정합성등 고려하여 어떤 브로커의 파티션으로 메시지를 보내야 할지 전략적으로 결정됨"),"\n"),"\n",t.createElement(l.h2,null,"컨슈머 : 메시지를 읽는다."),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,"여러 컨슈머가 구성된 경우 어떤 브로커의 파티션에서 메시지를 읽어들일지 전략적으로 결정 subscribe & poll 하면서 데이터를 가져온다."),"\n",t.createElement(l.li,null,"다른 메시지 시스템과다르게 컨슈머가 메시지를 받아도 카프카안에 메시지가 사라지지 않는다!"),"\n",t.createElement(l.li,null,"프로듀서에서 클리이언트 쪽으로 메시지를 보냈을때 카프카 안에 토픽안에 여러 파티션에 저장"),"\n",t.createElement(l.li,null,"컨슈머들이 파티션에서 저장된 메시지를 가져온다."),"\n",t.createElement(l.li,null,"auto.offset.rest (중요)","\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,"컨슈머가 토픽에 처음 접속하여 메시지를 가져올 때 가장 오래된 처음 offset 부터 가져올지,가장 최근인 마지막 offset 부터 가져올지 결정하는 파라미터"),"\n"),"\n"),"\n",t.createElement(l.li,null,"컨슈머는 브로커에서 메시지를 가져올 때 자기가 지금 어디까지 읽었는지에 대한 정보를 먼저 참조"),"\n",t.createElement(l.li,null,"read offset 을 가지고 있어서 자기가 어디까지 읽어 왔는지 알 수 있다"),"\n"),"\n",t.createElement(l.h2,null,"오프셋 = 일련 번호"),"\n",t.createElement(l.p,null,"메시지를 잘못 보낸 경우? 변경 불가"),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,"개별 파티션은 정렬되고, 변경 할 수 없는(immutable) 일련의 레코드로 구성된 로그 메시지"),"\n",t.createElement(l.li,null,"개별 파티션 끼리 독립적"),"\n"),"\n",t.createElement(l.p,null,"보통 동일 서버에서 분산 처리를 하지 않고\n카프카 클러스터 안에\nip 만 다른 동일한 하드웨어가 아니라 하드웨어가 아예 분리된 구조에서"),"\n",t.createElement(l.h2,null,"가용성?"),"\n",t.createElement(l.p,null,"분산 시스템을 구성했는데 한 서버가 내려가면?"),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,"replicate-fator = 2 로 쓴다면 가용성을 높힌다."),"\n",t.createElement(l.li,null,"리더와 팔로워 구조로 복제 (메시지->파티션1 리더- >팔로워)"),"\n",t.createElement(l.li,null,"가용성(可用性, 영어: availability)이란 서버와 네트워크, 프로그램 등의 정보 시스템이 정상적으로 사용 가능한 정도를 말한다."),"\n"),"\n",t.createElement(l.h2,null,"메시지를 send 할때 객체 직렬화 한다 (시리얼라이저)가 동작해 string 을 바이트 코드로 바꿈 -> 파티셔닝 단계"),"\n",t.createElement(l.h2,null,"키 값을 가지지 않는 메시지 전송을 할 때 어떻게 파티션을 분배할지"),"\n",t.createElement(l.p,null,"라운드 로빈은 최대한 메시지를 파티션에 균일하게 분배하려는 전략으로\n메시지 배치를 순차적으로 다른 파티션으로 전송"),"\n",t.createElement(l.h2,null,"션슈머 그룹"),"\n",t.createElement(l.p,null,"컨슈머 그룹과 컨슈머의 관계,파티션 등,컨슈머 그룹 삭제"),"\n",t.createElement(l.h2,null,"사용 예시"),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,"브로커 하나"),"\n",t.createElement(l.li,null,"서버 하나"),"\n"))}var a=function(e){void 0===e&&(e={});const{wrapper:l}=Object.assign({},(0,u.RP)(),e.components);return l?t.createElement(l,e,t.createElement(r,e)):r(e)},c=n(7292);function m(e){return t.createElement(c.A,e,t.createElement(a,e))}c.A}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-server-infra-2024-03-14-infra-messaging-system-kafka-mdx-1393a29b327758f077eb.js.map